# 「ああそうか！」アルゴリズム

* 2分探索を上手に使いましょう
* 基本アルゴリズムを組み合わせましょう
* ソートを使ってまとまりを作ることができる

などなど考えつつ、問題を正確に把握したら、じっくりとアルゴリズムを考えましょう。


## Q1. 与えられた単語すべてのアナグラムを辞書を用いて探せ！

一つ一つ単語をソートし、辞書の単語もソートして比較していく。

### Q1-発展. アナグラムを探す前に辞書をいじれたら？

辞書の単語をソートしてシグニチャーを作成し、それをソート。  
そこから2分探索する

## Q2. 4,300,000,000の32ビット整数から重複を探せ！

1. 十分なメモリがあった場合(500MB以上)

整数をビット列にマッピングする。  
整数に該当するビット位置のフラグが立っていてら重複整数として認識する。

2. 十分なメモリがない場合

0-999, 1000-1999, ...のようにブロックに分けてカウントしていく。  
例えば、1000-1999ブロックのカウントが1001であった場合は、  
1つの整数が重複していることがわかる。


### 本に載っている答え

2分探索でわかる。  
というのも真ん中の位置の数値が21億...より小さければ真ん中より下で重複していることがわかる・・・ってことかな。  
ちょっと違う気もする。

ソートされてる前提か？

## Q3. 配列を回転させるアルゴリズム。ブロック方式とお手玉方式を実装せよ！

1. ブロック方式

n個の配列をi個回転させるとき、  
最初のi個の配列をtemporary配列に入れて、  
n-i-1番目以降を0番目以降まで移動し、  
最後にtemporary配列をその後ろにくっつける方式

`src/block_rotate.c`

2. お手玉方式

n個の配列をi個回転させるとき、  
0番目の変数をtemporary変数に入れて、  
次にi番目を0番目へ、2i番目をi番目へ・・・  
次は1番目をtemporaryへ、i+1番目を1番目へ、2i+1番目をi+1番目へ・・・  
と言った感じで全要素がロテートするまで繰り返す。

`src/juggle_rotate.c`

### どちらのプログラムにもiとnの最大公約数が関係しているのがわかりますか？

わからん。

ブロックは関係無さそう？

お手玉方式は、GCDの数だけループするという関係があるらしい。  
コセットの数??
