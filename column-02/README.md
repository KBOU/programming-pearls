# 「ああそうか！」アルゴリズム

* 2分探索を上手に使いましょう
* 基本アルゴリズムを組み合わせましょう
* ソートを使ってまとまりを作ることができる

などなど考えつつ、問題を正確に把握したら、じっくりとアルゴリズムを考えましょう。


## Q1. 与えられた単語すべてのアナグラムを辞書を用いて探せ！

一つ一つ単語をソートし、辞書の単語もソートして比較していく。

### Q1-発展. アナグラムを探す前に辞書をいじれたら？

辞書の単語をソートしてシグニチャーを作成し、それをソート。  
そこから2分探索する

## Q2. 4,300,000,000の32ビット整数から重複を探せ！

1. 十分なメモリがあった場合(500MB以上)

整数をビット列にマッピングする。  
整数に該当するビット位置のフラグが立っていてら重複整数として認識する。

2. 十分なメモリがない場合

0-999, 1000-1999, ...のようにブロックに分けてカウントしていく。  
例えば、1000-1999ブロックのカウントが1001であった場合は、  
1つの整数が重複していることがわかる。


### 本に載っている答え

2分探索でわかる。  
というのも真ん中の位置の数値が21億...より小さければ真ん中より下で重複していることがわかる・・・ってことかな。  
ちょっと違う気もする。

ソートされてる前提か？

## Q3. 配列を回転させるアルゴリズム。ブロック方式とお手玉方式を実装せよ！

1. ブロック方式

n個の配列をi個回転させるとき、  
最初のi個の配列をtemporary配列に入れて、  
n-i-1番目以降を0番目以降まで移動し、  
最後にtemporary配列をその後ろにくっつける方式

`src/block_rotate.c`

2. お手玉方式

n個の配列をi個回転させるとき、  
0番目の変数をtemporary変数に入れて、  
次にi番目を0番目へ、2i番目をi番目へ・・・  
次は1番目をtemporaryへ、i+1番目を1番目へ、2i+1番目をi+1番目へ・・・  
と言った感じで全要素がロテートするまで繰り返す。

`src/juggle_rotate.c`

### どちらのプログラムにもiとnの最大公約数が関係しているのがわかりますか？

わからん。

ブロックは関係無さそう？

お手玉方式は、GCDの数だけループするという関係があるらしい。  
コセットの数??

## Q4. ブロック方式、お手玉方式、逆転方式の実行速度を比べる

iが大きくなるとお手玉方式は極端に遅くなる。

n = 10,000,000  
i = 4,200  

<table>
<tr> <td>方式</td> <td>実行速度</td> </tr>
<tr> <td>ブロック</td> <td>0.03秒</td> </tr>
<tr> <td>お手玉</td> <th>0.47秒</th> </tr>
<tr> <td>逆転</td> <td>0.05秒</td> </tr>
</table>

## Q5. 配列abcのcbaにロテーションするにはどうする？

aの逆転をar, bの逆転をbr, cの逆転をcrとする。

1. ar b c
2. ar br c
3. ar br cr
4. c b a &lt;- (ar br cr)r

## Q6. プッシュホンで名前検索

携帯電話の数字押すところについてるあのアルファベットをイメージ。  
たとえば、1という数字はabcに対応、2はdefに対応している。

今回のプッシュホンの場合、携帯と違い、1を三回押してもcにはならないこと、  
つまり1は常にabcのいずれかに対応しているということ。

この状態で、mikeという名前を入力した時に(6453)、  
nikeやmikeなどの候補をすべて返すようにするにはどうすればよいか？


mikeという名前が登録されたら6453というキーでハッシュマップに登録し、  
nikeが登録されたら同じく6453のキーでハッシュマップに登録するが、  
mikeノードの後ろにnikeノードをくっつけることで衝突をハンドルすればOKなのではないだろうか。


## Q7.  4000x4000の磁気テープ上の配列を転置する。

1. 列順に並んだ行列を用意する
2. 行番号列番号を各要素に与える
3. 行番号でソートして
4. 列番号でソートすると転置になる。

とあるがようわからん・・・

## Q8. 要素nこの実数の配列と実数tが与えられた時、要素k個の部分配列の中にtを超えないようなものがあるかを検証する

nをソートして、下からk個とってtを超えないことを検証する。

## Q9. 逐次探索と2分探索、何回探索すれば2分探索した甲斐がある？


逐次探索 = kO(n)
2分探索 =  O(n log n) + kO(log n)

細かいことを無視すれば、  
`kn = n log n + k log n`  
となるkを探す。

`k = n log n / (n - log n) = log n / (1 - (log n)/n)`

であってんのか・・・？


## Q10. 電球の容積を正確に測るにはどうすればよいか？

計量カップに電球を入れ、電球が水に浸るまで水を入れる。  
そのときの容積と、電球を抜いた時の容積を比較すれば電球の容積が出るはず。
