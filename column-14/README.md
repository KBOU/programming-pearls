# ヒープ

## ヒープとは？

* 木構造
* 親より子どもたちの方が大きい値を保持している
* 短い枝と長い枝の差が最大で1
* 左下から埋まってく
* node(i)の子供はnode(2i)とnode(2i+1)
* 検索、挿入がO(log n)

* ヒープ `src/heap.hpp`
* 順位キュー `src/priqueue.hpp`


## Q1. 順位キューの速い実装

* shiftdownでswapのtmp変数を外出しする
* shiftupで番兵を使う

## Q2. shiftdown(l, u)に書き換える

```
void shiftdown(l, u)
	i = l
	loop
		c = 2*i
		if c > u
			break
		if c + 1 <= u
			if x[c+1] < x[c]
				c++
		if x[i] <= x[c]
			break
		swap(c, i)
		i = c
```

なぜO(n)になるのかはわからない・・・

## Q3. 速いHeapsortを作れ！

Q1とQ2の組み合わせ。
O(n log n)らしいか定数項が小さくなるらしい。  
(なぜQ2でO(n)になったのにここでO(n log n)なのかわからない・・・)

## Q4. 順位キューは以下の問題を解くのにどのように使えるか？

* ハフマン符号  
よくわかりません。  
http://ja.wikipedia.org/wiki/%E3%83%8F%E3%83%95%E3%83%9E%E3%83%B3%E7%AC%A6%E5%8F%B7  
PriorityQueueにいれてハフマン木を作るのか。なんとなくわかったような。
* たくさんの浮動小数点の和  
順位キューで小さいもんから足していくことで桁落ちを防ぐ
* ディスクファイルにある10億個の数の中から大きい100万個の数をみつける  
サイズ100万の大きい順ヒープの順位キューを作成してファイルをなめてく
* ソートされている小さなファイルを束ねて1つのソートされた大きなファイルを作る  
nこのファイルから最小のものを1つ取り出し、ヒープに入れて・・・を繰り返す

## Q5. 瓶詰め問題。1の容積のビンに0-1までの容積の物体を入れるときに便の本数を最小にする。

ビンの残り容量をHeapにしてどのビンもだめならビンを追加みたいにしていけばいけるはず。

## Q6. ファイルのi番目のブロックにO(log i)でアクセスしたい

各ブロックに2*i番目のブロックへのポインタをもたせる

## Q7. 2分探索を割り算じゃなくて掛け算でしたい。

2分探索木をつくれば掛け算でいけるはず。

## Q8. [0, k)の範囲の整数を入れるのに適当な順位キューを実装する。キューのサイズはkよりはるかに大きい

キューのi番目にiを入れるとinsertはO(1)だけど・・・

## Q9. ヒープ構造で挿入・取出をO(log n)にするのが最速であることを証明

例えばO(n), O(1)にできたとしても挿入・取出しを同数すればO(log n)の方が速い。  
が、証明はできない。

## Q10. トーナメントで2番目に強い選手が決勝に出る確率。

完全に実力のみで勝負が決まるとすると、
1番強い選手の反対ブロックにいればいいので、確率1/2となる。

シードの決め方は1位と2位を反対ブロックに入れて、
3位は2位のブロックを2分割して2位の反対ブロックへってかんじでいけばいいのでは？

## Q11. とばす
