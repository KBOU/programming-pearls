# コードチューニング

* 効率は問題になるまで気にしない！
* プロファイラを用意する！
* もっと上のレイヤーでチューニングできないか考える！

## Q1. とばす

## Q2. cacheを利用してmalloc回数を減らす

`src/cache_heap.c`

## Q3. お手玉プログラムはなぜ%演算子の置き換えは有効でwhileの置き換えは有効でないのか？また%をwhileで置き換えても有効なケースは?

全然わからん。

## Q4. 部分配列の最大値を返す関数がマクロを使った場合、なぜあほみたいに時間がかかるか考察する。

`src/sub_max.c`

たしかにむちゃおそい。

マクロが展開されるので、
```
max(x[n-1], arrmax(n-1))は
(x[n-1] > arrmax(n-1)) ? x[n-1] : arrmax(n-1)に展開される。
```

* n=1のときarrmaxが呼ばれる回数は
    # arrmax(1)
* n=2のとき
	# arrmax(2)
	# arrmax(1)
	# arrmax(1)
* n=3のとき
	# arrmax(3)
	# arrmax(2)
	# arrmax(1)
	# arrmax(1)
	# arrmax(2)
	# arrmax(1)
	# arrmax(1)

と考えていくと呼び出される回数をA(n)と考えると、

`A(n) = 2A(n-1) + 1`

となる。

これをとくと、
`A(n) = 2^n-1`
となり・・・、  
たしかにn=30とかするとすでにやばいことになるのは頷ける。(検証があってればね)

## Q5. ソートされていない配列で二分探索したら？

要素を探せないケースが多々出てくる。

## Q6. isupper, islower, isdigitとかを実装してみる。

```
if (c >= '0' && c <= '9') {
	return true
} else {
	return false
}
```

的な感じでもいけるが、予め配列で持っとくという手もある。(コードチューニングの章だし・・・)

## Q7.  1兆ビットの1がたっているビット個数のカウントをどうする？

1兆ビットだとだいたい11-12GBなのでそもそもメモリに載せるときに分割して乗せないときついはず。

さらに普通にカウントするととんでもなく時間がかかりそう。

```
int pop(unsigned x)
{
    x = x - ((x >> 1) & 0x55555555);
    x = (x & 0x33333333) + ((x >> 2) & 0x33333333);
    x = (x + (x >> 4)) & 0x0F0F0F0F;
    x = x + (x >> 8);
    x = x + (x >> 16);
    return x & 0x0000003F;
}
```

こういうの使うとははやくなりそう。

## Q8. 配列からmaxを求めるときに番兵を使う。

```
i = 0
while i < n
	max = x[i]
	x[n] = max
	i++
	while x[i] < max
		i++
```

なるほどーって感じですが、読みづらいから使いたくないな。

## Q9-11. とばす

## Q12. y = A(n) * x^n + A(n-1) * x^(n-1) + ... + a1 * x + a0の計算両をへらす。

```
y = a[0]
xi = 1
for i = [1, n]
	xi = x * xi
	y = y + a[i] * xi
```

だと2n回の掛け算だが、

```
y = a[n]
for i = [n-1, 0]
	y = y * x + a[i]
```

だとn回
