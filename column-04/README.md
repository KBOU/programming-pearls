# 正しいプログラムを書く

プログラムを書く前に擬似コードを書いてから書く。  
たしかに書いている間に矛盾点とかが分かる事が多い。


* 表明。
プログラムの状態のこと
* 関数の前提条件と戻り値。
例えば、int型の入力が一つで、入力が-1なら-1をそのまま返すとかそんな感じ。

再起じゃないbinary searchは

`src/binary_search.c`

## Q1. 2分探索でオーバーフローなどが発生しないことを示す

入力値の表明をすれば示せる。

## Q2. 最初に探している数値(t)が出てくる位置を取得する。

条件：

* 配列はソートされている
* 配列内の要素は同じ値のものがある
* 同じ値のなかで一番最初のindexを返す
* O(ln n)で

1. 普通に2分探索する
2. そっから左端のindexと探しだしたtで2文探索する。

だとO(ln n) + O(ln n/2) + O(ln n/4) + ...= O(ln n)になる・・・のかな

## Q3. 2分探索を再帰で書いてみる

`src/binary_search_re.c`

## Q4. 2分探索した回数を検証してみる

`src/binary_search_num.c`

## Q5. 以下のループが終了することを示す。

```
while x != 1 do
	if xが偶数
		x = x/2
	else
		x = 3x + 1
```

"コラッツの問題"と呼ばれる問題らしい。  
まだ証明はできてないらしい。


## Q6. 黒豆と白豆問題

黒豆と白豆がいくつかはいっている缶がある。  
その缶からランダムに2つ選んで、
色が違えば白のみ缶に戻す。同じ色だったら両方捨てる。

というのを繰り返した時に、

1. 必ずこの操作は終息する
2. 最後に残った豆から白豆、黒豆の個数について何が言えるか

を考察する。


1について、絶対に毎回1個以上は減らすので、絶対に終息する。  
2についてですが、白豆は2こずつしか減らないので、白豆が最後に残った場合は白豆の個数がき数個であるといえる。

## Q7. x = [0, 1]で交わらない直線をn個ひいて、任意に与えられる(x, y)がどの2つの直線間に含まれるかを探す

2分探索で求めることができそう。  
というのもどの直線も交わっていないので、序列は変わらないから。

## Q8. 2分探索をもっと早くする方法はあるか？

理論上、比較回数はlog nを下回ることはできないが、他の部分で何とかならないかという話。

わ、わからん・・・

## Q9.  次のコードの懸賞をしてみる。

こんな感じでいいのだろうか・・・ようわからん

```
i = 0

while i < n
	/* 0 <= i < n */
	/* 配列bの要素と配列cの同じindexにある要素をたす */
	a[i] = b[i] + c[i]
	i = i + 1
	/* 1 <= i <= n */
```

```
/* 最大値を配列の最初の要素で初期化 */
max = x[0]
i = 1
while i < n do
	/* 1 <= i < n */
	if x[i] > max
		/* x[i] > maxならmaxにx[i]を代入 */
		max = x[i]
	i = i + 1
	/* 2 <= i <= n */
```


```
i = 0
while i < n && x[i] != t
	/*
		0 <= i < nでtが見つかっていない状態
		tが見つかった場合0 <= i <= n-1
	*/
	i = i + 1

if i >= n:
	/* tが見つからなかった場合、-1を代入 */
	p = -1
else
	/* tが見つかったインデックスを代入 */
	p = i
```

```
function exp(x, n)
	/* 前提条件: n >= 0
	   結果: result = x^n
	*/

	if n = 0
		/* nが0ならすべての数字は1 */
		return 1
	else if nが偶数なら
		/* x^((n/2)*2) */
		return exp(x, n/2)の2乗
	else
		/* x * x^(n-1) */
		return x * exp(x, n-1)
```

以下、expをループで実現したもの

`src/exp.c`

## Q10. 2分探索のコードにバグを埋め込んで検証をしてみる

とばす

## Q11. int binarysearch(DataType[] x, int n)を実装する

int binarysearch(DataType[] x, int n)を実装する・・・  
たぶんint binarysearch(DataType[] x, DataType t, int n)じゃないかと。

ここで普段と違うところというか
`src/binary_search.c`
と違うところは引数にleft, rightがないところ。

これをどうやって実現するかですが・・・ポインタ使えばいけるかも?

`src/binary_search_final.c`
